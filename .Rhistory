}
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])$form[[2]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
form <- Sepal.Length~Sepal.Width
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])$form[[2]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
testing(folds$splits[[i]])$form[[2]]
testing(folds$splits[[1]])$form[[2]]
testing(folds$splits[[1]])$"form[[2]]"
testing(folds$splits[[1]])$'form[[2]]'
testing(folds$splits[[1]])$as.character(form[[2]])
form[[2]]
testing(folds$splits[[1]])["form[[2]]"]
testing(folds$splits[[1]])
testing(folds$splits[[1]])$Sepel.Length
testing(folds$splits[[1]])$(Sepel.Length)
testing(folds$splits[[1]])$"Sepel.Length"
testing(folds$splits[[1]])$"Sepal.Length"
testing(folds$splits[[1]])$"form[[2]]"
testing(folds$splits[[1]])[[as.character(formula[2])]]
testing(folds$splits[[1]])[[as.character(formula[2])]]
testing(folds$splits[[1]])[as.character(formula[2])]
testing(folds$splits[[1]])[[as.character(form[2])]]
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
View(rmses)
form[[2]]
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
folds <- vfold_cv(iris, 10)
form <- Sepal.Length~Sepal.Width
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
form <- Sepal.Length~Sepal.Width
folds <- vfold_cv(iris, 10)
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
testing(folds$splits[[i]]
(testing(folds$splits[[i]])[[as.character(form[2])]]
testing(folds$splits[[i]])[[as.character(form[2])]]
testing(folds$splits[[i]])[[as.character(form[2])]]
testing(folds$splits[[1]])[[as.character(form[2])]]
testing(folds$splits[[i]])
testing(folds$splits[[1]])
?casl_util_rmse
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
casl_util_rmse(testing(folds$splits[[1]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[1]]), lambda), testing(folds$splits[[1]])))
casl_util_rmse(testing(folds$splits[[1]])[[as.character(form[2])]],
ridge_predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]])))
ridge_predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]]))
ridge_predict <- function(object, ...) {
dots <- list(...)
x_frame <- dots[[1]]
if (!is.data.frame(x_frame)) {
stop(red("The first argument should be a data.frame of values",
"to predict"))
}
X <- model.matrix(attributes(object)$formula, x_frame)
X %*% object
}
x<-ridge_regression(Sepal.Length~Sepal.Width, iris, 0.1)
ridge_predict(x, iris)
ridge_predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]]))
ridge_predict(ridge_regression(Sepal.Length~Sepal.Width, iris, 0.1), iris)
training(folds$splits[[1]])
testing(folds$splits[[1]])
ridge_predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]]))
predict.ridge_regression <- function(object, ...) {
dots <- list(...)
x_frame <- dots[[1]]
if (!is.data.frame(x_frame)) {
stop(red("The first argument should be a data.frame of values",
"to predict"))
}
X <- model.matrix(attributes(object)$formula, x_frame)
X %*% object
}
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]]))
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
predict(ridge_regression(form, training(folds$splits[[1]]), 0.1), testing(folds$splits[[1]]))
ridge_regression(form, training(folds$splits[[1]]), 0.1)
ridge_regression(Sepal.Length~Sepal.Width, training(folds$splits[[1]]), 0.1)
training(folds$splits[[1]])
form
ridge_regression(form, training(folds$splits[[1]]), 0.1)
ridge_regression(Sepal.Length~Sepal.Width, iris, 0.1)
ridge_regression(form, iris, 0.1)
training(folds$splits[[1]])
ridge_regression(form, training(folds$splits[[1]]), 0.1)
ridge_regression(form, training(folds$splits[[1]]), 0.1)
training(folds$splits[[1]])
folds$splits[[1]]
training(folds$splits[[1]])
ridge_regression(form, training(folds$splits[[1]]), 0.1)
ridge_regression <- function(form, data, lambda = 0) {
#  rownames(data) <- NULL
X <- model.matrix(form, data)
# Y <- data[as.numeric(rownames(X)), as.character(form)[2]]
Y <- data[[as.character(form)[2]]][as.numeric(rownames(X))]
ret <- solve( crossprod(X) + diag(rep(lambda, ncol(X))) ) %*% t(X) %*% Y
attributes(ret)$formula <- form
class(ret) <- c(class(ret), "ridge_regression")
ret
}
library(rsample)
library(doParallel)
library(casl)
registerDoParallel(6)
folds <- vfold_cv(iris, 10)
form <- Sepal.Length~Sepal.Width
ridge_regression(form, training(folds$splits[[1]]), 0.1)
x<-training(folds$splits[[1]])
ridge_regression(form, x, 0.1)
View(x)
ridge_regression(form, iris, 0.1)
ridge_regression(form, training(folds$splits[[2]]), 0.1)
ridge_regression(form, training(folds$splits[[11]]), 0.1)
ridge_regression(form, training(folds$splits[[3]]), 0.1)
ridge_regression(form, training(folds$splits[[3]]))
knitr::opts_chunk$set(echo = TRUE)
n <- 1000; p <- 25
beta <- c(1, rep(0, p-1))
X  <- matrix(rnorm(n * p), ncol = p)
svals <- svd(X)$d
max(svals)/min(svals)
```{r}
N <- 1e4; 12_errors <- rep(0, N)
N <- 1e4; l2_errors <- rep(0, N)
mean(l2_errors)
max(svals)/min(svals)
mean(l2_errors)
N <- 1e4; l2_errors <- rep(0, N)
for (k in 1:N) {
y <- X %*% beta + rnorm(n)
betahat <- casl_ols_svd(X, y)
l2_errors[k] <- sqrt(sum((betahat - beta)^2))
}
N <- 1e4; l2_errors <- rep(0, N)
for (k in 1:N) {
y <- X %*% beta + rnorm(n)
betahat <- casl_ols_svd(X, y)
l2_errors[k] <- sqrt(sum((betahat - beta)^2))
}
mean(l2_errors)
```{r}
max(svals) / min(svals)
alpha <- 0.001
X[,1] <- X[,1] * alpha + X[,2] * (1 - alpha)
svals <- svd(X)$d
max(svals) / min(svals)
N <- 1e4; l2_errors <- rep(0, N)
for (k in 1:N) {
y <- X %*% beta + rnorm(n)
betahat <- solve(crossprod(X), crossprod(X, y))
l2_errors[k] <- sqrt(sum((betahat - beta)^2))
}
mean(l2_errors)
lambda <- 0.1
svals <- svd(X)$d
(max(svals) +  lambda) / (min(svals) + lambda)
lambda <- 0.3
svals <- svd(X)$d
(max(svals) +  lambda) / (min(svals) + lambda)
lambda <- 0.13
svals <- svd(X)$d
(max(svals) +  lambda) / (min(svals) + lambda)
lambda <- 0.4
svals <- svd(X)$d
(max(svals) +  lambda) / (min(svals) + lambda)
N <- 1e4; `12_errors` <- rep(0, N)
for (k in 1:N){
y <- X %*% beta + rnorm(n)
betahat <- solve(crossprod(X) + lambda, crossprod(X,y))
`12_errors`[k] <- sqrt(sum((betahat - beta)^2))
}
mean(`12_errors`)
N <- 1e4; l2_errors <- rep(0, N)
for (k in 1:N) {
y <- X %*% beta + rnorm(n)
betahat <- casl_ols_svd(X, y)
l2_errors[k] <- sqrt(sum((betahat - beta)^2))
}
library(casl)
N <- 1e4; l2_errors <- rep(0, N)
for (k in 1:N) {
y <- X %*% beta + rnorm(n)
betahat <- casl_ols_svd(X, y)
l2_errors[k] <- sqrt(sum((betahat - beta)^2))
}
predict.ridge_regression <- function(object, ...) {
dots <- list(...)
x_frame <- dots[[1]]
if (!is.data.frame(x_frame)) {
stop(red("The first argument should be a data.frame of values",
"to predict"))
}
X <- model.matrix(attributes(object)$formula, x_frame)
X %*% object
}
ridge_regression(form, training(folds$splits[[3]]), 0.1)
training(folds$splits[[1]])
model.matrix(form, training(folds$splits[[3]]))
X<-model.matrix(form, training(folds$splits[[3]]))
training(folds$splits[[3]])[[as.character(form)[2]]][as.numeric(rownames(X))]
as.numeric(rownames(X))
rownames(X)
training(folds$splits[[3]])[as.numeric(rownames(X))][[as.character(form)[2]]]
rownames(X)
training(folds$splits[[3]])[[as.character(form)[2]]][as.numeric(rownames(X))]
training(folds$splits[[3]])[[as.character(form)[2]]]
ridge_regression <- function(form, data, lambda = 0) {
#  rownames(data) <- NULL
X <- model.matrix(form, data)
# Y <- data[as.numeric(rownames(X)), as.character(form)[2]]
Y <- data[[as.character(form)[2]]]
ret <- solve( crossprod(X) + diag(rep(lambda, ncol(X))) ) %*% t(X) %*% Y
attributes(ret)$formula <- form
class(ret) <- c(class(ret), "ridge_regression")
ret
}
ridge_regression(Sepal.Length~Sepal.Width, iris, 0.1)
rmses <- foreach(lambda = c(0.1,0.2), .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = lambdas) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
library(crayon)
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = lambdas) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
library(crayon)
library(dplyr)
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = lambdas) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = c(0.1,0.2)) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
View(edf)
min(edf$mean)
edf$mean==min(edf$mean)
edf$lambda[edf$mean==min(edf$mean)]
optimize_lambda(iris, Sepal.Length~Sepal.Width, seq(0, 0.5, 0.005))
optimize_lambda <- function(data, form, lambdas, fold=10) {
registerDoParallel(6)
folds <- vfold_cv(data, fold)
rmses <- foreach(lambda = lambdas, .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = lambdas,) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
return(edf$lambda[edf$mean==min(edf$mean)])
}
optimize_lambda(iris, Sepal.Length~Sepal.Width, seq(0, 0.5, 0.005))
usethis::use_test("ridge_regression")
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width, iris, 0.1)
fit2 <- fit <- glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = 0.1)
expect_equivalent(fit1$coefficients, fit2$coefficients,
tolerance = 1e-5)
})
library(testthat)
library(glmnet)
context("Test the output of homework 2.")
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width, iris, 0.1)
fit2 <- fit <- glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = 0.1)
expect_equivalent(fit1$coefficients, fit2$coefficients,
tolerance = 1e-5)
})
ridge_regression <- function(form, data, lambda = 0) {
#  rownames(data) <- NULL
X <- model.matrix(form, data)
# Y <- data[as.numeric(rownames(X)), as.character(form)[2]]
Y <- data[[as.character(form)[2]]]
ret <- solve( crossprod(X) + diag(rep(lambda, ncol(X))) ) %*% t(X) %*% Y
attributes(ret)$formula <- form
class(ret) <- c(class(ret), "ridge_regression")
ret
}
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width, iris, 0.1)
fit2 <- fit <- glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = 0.1)
expect_equivalent(fit1$coefficients, fit2$coefficients,
tolerance = 1e-5)
})
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width, iris, 0.1)
fit2 <- fit <- glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = c(0.1))
expect_equivalent(fit1$coefficients, fit2$coefficients,
tolerance = 1e-5)
})
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width, iris, 0.1)
fit2 <- glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = c(0.1))
expect_equivalent(fit1$coefficients, fit2$coefficients,
tolerance = 1e-5)
})
glmnet(iris$Sepal.Width, iris$Sepal.Length, alpha = 0, lambda = c(0.1))
iris$Sepal.Width
iris[Sepal.Width]
iris["Sepal.Width"]
glmnet(iris["Sepal.Width"], iris$["Sepal.Length"], alpha = 0, lambda = c(0.1))
glmnet(iris["Sepal.Width"], iris["Sepal.Length"], alpha = 0, lambda = c(0.1))
x <- iris %>% select(Sepal.Width) %>% data.matrix()
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)
x <- iris %>% select(Sepal.Width) %>% data.matrix()
glmnet(x, iris["Sepal.Length"], alpha = 0, lambda = c(0.1))
View(iris)
iris["Sepal.Width","Petal.Length"]
iris["Sepal.Width","Petal.Length"]
x <- iris %>% select(Sepal.Width,Petal.Length) %>% data.matrix()
glmnet(x, iris["Sepal.Length"], alpha = 0, lambda = c(0.1))
glmnet(x, iris$Sepal.Length, alpha = 0, lambda = c(0.1))
?glmnet
coef(glmnet(x, iris$Sepal.Length, alpha = 0, lambda = c(0.1)))
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width + Petal.Length, iris, 0.1)
fit1
fit1[,1]
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width + Petal.Length, iris, 0.1)
x <- iris %>% select(Sepal.Width,Petal.Length) %>% data.matrix()
fit2 <- coef(glmnet(x, iris$Sepal.Length, alpha = 0, lambda = c(0.1)))
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1e-5)
})
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ Sepal.Width + Petal.Length, iris, 0.1)
x <- iris %>% select(Sepal.Width,Petal.Length) %>% data.matrix()
fit2 <- coef(glmnet(x, iris$Sepal.Length, alpha = 0, lambda = c(0.1)))
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1)
})
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ ., iris, 0.1)
fit2 <- lm.ridge(Sepal.Length ~ ., iris, lambda = 0.1)
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1)
})
library(MASS)
context("Test the output of homework 2.")
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ ., iris, 0.1)
fit2 <- lm.ridge(Sepal.Length ~ ., iris, lambda = 0.1)
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1)
})
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ ., iris, 0.1)
fit2 <- lm.ridge(Sepal.Length ~ ., iris, lambda = 0.1)
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1e-5)
})
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1e-1)
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ ., iris, 0.1)
fit2 <- lm.ridge(Sepal.Length ~ ., iris, lambda = 0.1)
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 1e-1)
})
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 2e-1)
test_that("You ridge regression function works in an easy case.", {
data(iris)
fit1 <- ridge_regression(Sepal.Length ~ ., iris, 0.1)
fit2 <- lm.ridge(Sepal.Length ~ ., iris, lambda = 0.1)
expect_equivalent(fit1[,1], coef(fit2),
tolerance = 2e-1)
})
usethis::use_test("optimize_lambda")
optimize_lambda <- function(data, form, lambdas, fold=10) {
registerDoParallel(6)
folds <- vfold_cv(data, fold)
rmses <- foreach(lambda = lambdas, .combine = rbind) %dopar% {
foreach(i = seq_len(nrow(folds)), .combine = c) %do% {
casl_util_rmse(testing(folds$splits[[i]])[[as.character(form[2])]],
predict(ridge_regression(form, training(folds$splits[[i]]), lambda), testing(folds$splits[[i]])))
}
}
edf <- tibble(mean = apply(rmses, 1, mean),
sd = apply(rmses, 1, sd),
lambda = lambdas,) %>%
mutate(upper = mean + 2 * sd / sqrt(nrow(.)),
lower = mean - 2 * sd / sqrt(nrow(.)))
return(edf$lambda[edf$mean==min(edf$mean)])
}
library(MASS)
library(glmnet)
cv.glmnet(model.matrix(response ~ ., iris), as.matrix(iris[,1]), alpha = 0)
cv.glmnet(model.matrix(Sepal.length ~ ., iris), as.matrix(iris[,1]), alpha = 0)
cv.glmnet(model.matrix(Sepal.Length ~ ., iris), as.matrix(iris[,1]), alpha = 0)
cv.glmnet()
?cv.glmnet()
cv.glmnet(model.matrix(Sepal.Length ~ ., iris), as.matrix(iris[,1]), alpha = 0, lambda=seq(0, 0.5, 0.005))
cv.glmnet(model.matrix(Sepal.Length ~ ., iris), as.matrix(iris[,1]), alpha = 0, lambda=seq(0, 0.5, 0.005))$lambda.min
optimize_lambda(iris, Sepal.Length ~ ., seq(0, 0.5, 0.005))
library(dplyr
library(glmnet)
library(rsample)
library(doParallel)
library(casl)
library(dplyr)
library(crayon)
optimize_lambda(iris, Sepal.Length ~ ., seq(0, 0.5, 0.005))
predict.ridge_regression <- function(object, ...) {
dots <- list(...)
x_frame <- dots[[1]]
if (!is.data.frame(x_frame)) {
stop(red("The first argument should be a data.frame of values",
"to predict"))
}
X <- model.matrix(attributes(object)$formula, x_frame)
X %*% object
}
optimize_lambda(iris, Sepal.Length ~ ., seq(0, 0.5, 0.005))
test_that("You oitimze lambda function works in an easy case.", {
data(iris)
l1 <- optimize_lambda(iris, Sepal.Length ~ ., seq(0, 0.5, 0.005))
l2 <- cv.glmnet(model.matrix(Sepal.Length ~ ., iris), as.matrix(iris[,1]), alpha = 0, lambda=seq(0, 0.5, 0.005))
expect_equivalent(l1, l2$lambda.min, tolerance = 1e-1)
})
test_that("You oitimze lambda function works in an easy case.", {
data(iris)
l1 <- optimize_lambda(iris, Sepal.Length ~ ., seq(0, 0.5, 0.005))
l2 <- cv.glmnet(model.matrix(Sepal.Length ~ ., iris), as.matrix(iris[,1]), alpha = 0, lambda=seq(0, 0.5, 0.005))
expect_equivalent(l1, l2$lambda.min, tolerance = 1e-2)
})
